#include "font_outline.h"


#include <vector>
#include <fstream>
#include <iostream>

FONT_OUTLINE_BEGIN

#ifdef _MSC_VER
#define MIN __min
#define MAX __max
#else
#define MIN std::min
#define MAX std::max
#endif





// Try to figure out what endian this machine is using. Note that the test
// below might fail for cross compilation; additionally, multi-byte
// characters are implementation-defined in C preprocessors.

#if (('1234' >> 24) == '1')
#elif (('4321' >> 24) == '1')
  #define BIG_ENDIAN
#else
  #error "Couldn't determine the endianness!"
#endif


// A simple 32-bit pixel.
struct Vec2
{
	Vec2() { }
	Vec2(float a, float b)
	: x(a), y(b) { }

	float x, y;
};


struct Rect
{
	Rect() { }
	Rect(float left, float top, float right, float bottom)
	: xmin(left), xmax(right), ymin(top), ymax(bottom) { }

	void Include(const Vec2 &r)
	{
		xmin = MIN(xmin, r.x);
		ymin = MIN(ymin, r.y);
		xmax = MAX(xmax, r.x);
		ymax = MAX(ymax, r.y);
	}

	float Width() const { return xmax - xmin + 1; }
	float Height() const { return ymax - ymin + 1; }

	float xmin, xmax, ymin, ymax;
};


// TGA Header struct to make it simple to dump a TGA to disc.

#if defined(_MSC_VER) || defined(__GNUC__)
#pragma pack(push, 1)
#pragma pack(1)               // Dont pad the following struct.
#endif

struct TGAHeader
{
	uint8   idLength,           // Length of optional identification sequence.
		  paletteType,        // Is a palette present? (1=yes)
		  imageType;          // Image data type (0=none, 1=indexed, 2=rgb,
							  // 3=grey, +8=rle packed).
	uint16  firstPaletteEntry,  // First palette index, if present.
		  numPaletteEntries;  // Number of palette entries, if present.
	uint8   paletteBits;        // Number of bits per palette entry.
	uint16  x,                  // Horiz. pixel coord. of lower left of image.
		  y,                  // Vert. pixel coord. of lower left of image.
		  width,              // Image width in pixels.
		  height;             // Image height in pixels.
	uint8   depth,              // Image color depth (bits per pixel).
		  descriptor;         // Image attribute flags.
};

#if defined(_MSC_VER) || defined(__GNUC__)
#pragma pack(pop)
#endif


bool
WriteTGA(const std::string &filename,
         const Pixel32 *pxl,
         uint16 width,
         uint16 height)
{
	std::ofstream file(filename.c_str(), std::ios::binary);
	if (file)
	{
		TGAHeader header;
		memset(&header, 0, sizeof(TGAHeader));
		header.imageType  = 2;
		header.width = width;
		header.height = height;
		header.depth = 32;
		header.descriptor = 0x20;

		file.write((const char *)&header, sizeof(TGAHeader));
		file.write((const char *)pxl, sizeof(Pixel32) * width * height);

		return true;
	}
	return false;
}


// A horizontal pixel span generated by the FreeType renderer.

struct Span
{
	Span() { }
	Span(int _x, int _y, int _width, int _coverage)
	: x(_x), y(_y), width(_width), coverage(_coverage) { }

	int x, y, width, coverage;
};

typedef std::vector<Span> Spans;


// Each time the renderer calls us back we just push another span entry on
// our list.

void
RasterCallback(const int y,
               const int count,
               const FT_Span * const spans,
               void * const user) 
{
	Spans *sptr = (Spans *)user;
	for (int i = 0; i < count; ++i) 
	sptr->push_back(Span(spans[i].x, y, spans[i].len, spans[i].coverage));
}


// Set up the raster parameters and render the outline.

void
RenderSpans(const FT_Library &library,
            FT_Outline * const outline,
            Spans *spans) 
{
	FT_Raster_Params params;
	memset(&params, 0, sizeof(params));
	params.flags = FT_RASTER_FLAG_AA | FT_RASTER_FLAG_DIRECT;
	params.gray_spans = RasterCallback;
	params.user = spans;

	FT_Outline_Render(library, outline, &params);
}


// Render the specified character as a colored glyph with a colored outline
// and dump it to a TGA.

//娓叉alpha?

//杩琛
inline void RenderColor(Pixel32* pxl, int imgWidth, int imgHeight, const Pixel32 &fontCol,
                const Pixel32 outlineCol)
{
	//
	int size = imgWidth*imgHeight;
	for(int i = 0; i < size; i++)
	{
		Pixel32 &dst = pxl[i];

		dst.r = dst.g = dst.b = dst.r*0.3 + dst.g*0.59 + dst.b * 0.11;
		float value = dst.r / 255.0f;
		if(value >=0.5)
		{
			dst.r = fontCol.r*(value);
			dst.g = fontCol.g*(value);
			dst.b = fontCol.b*(value);
		}
		else
		{
			dst.r = outlineCol.r*(1-value);
			dst.g = outlineCol.g*(1-value);
			dst.b = outlineCol.b*(1-value);
		}
	}
}

inline void RenderAlpha(Pixel32* pxl, int imgWidth, int imgHeight, char* alpha_map, int & color_top, int & color_bottom)
{
	//
	int size = imgWidth*imgHeight;
	int i = 0;
	for(int y = 0; y < imgHeight; y++)
	{
		for(int x = 0; x < imgWidth; x++)
		{
			Pixel32 &dst = pxl[i];

			dst.r = dst.g = dst.b = dst.r*0.3 + dst.g*0.59 + dst.b * 0.11;
			float value = dst.r / 255.0f;
			
			// alpha为255应该铁定是轮廓内的颜色,不为255一定是最边缘的颜色,
			// 然后剩下的都是灰度值， 颜色为轮廓色为轮廓色，为填充色为填充色。
			// 两者之前小于0.5为边色，>0.5为内色
			// 

			if(dst.a == 255)
			{
				if(value >= 0.5 && color_top < 0)
				{
					color_top = y;
				}
				if(value >= 0.5 && i > color_bottom)
				{
					color_bottom = y;
				}
				alpha_map[i] = (value*0.5+0.5)*255;
			}
			else
			{
				alpha_map[i] = (dst.a /255.0f*0.5)*255;
			}
			
			i++;
		}
	}
}

inline void clamp(float& value, float min, float max)
{
	if(value < min)
		value = min;
	else if(value > max)
		value = max;
}

bool
WriteOutline(const FT_Library &library,
                wchar_t ch,
                FT_Face &face,
                int size,
                const Pixel32 &fontCol,
                const Pixel32 outlineCol,
                float outlineWidth,
				char*& alpha_map,
				int& imgWidth, int& imgHeight,
				int & color_top, int& color_bottom,
				FontRect& outRect,
				int &xAdvance)
{
	// Set the size to use.
	if(size > -1)
	{
		if ((!FT_Set_Char_Size(face, size << 6, size << 6, 90, 90) == 0))
			return false;
	}

	color_top = -1;
	color_bottom = -1;

	// Load the glyph we are looking for.
	/*
	FT_UInt gindex = FT_Get_Char_Index(face, ch);

	if (!(FT_Load_Glyph(face, gindex, FT_LOAD_NO_BITMAP) == 0))
		return false;*/
 
	// Need an outline for this to work.
	if (face->glyph->format != FT_GLYPH_FORMAT_OUTLINE)
		return false;
	
	// Render the basic glyph to a span list.
	Spans spans;
	RenderSpans(library, &face->glyph->outline, &spans);

	outRect.x = face->glyph->metrics.horiBearingX >> 6;
	outRect.y	= face->glyph->metrics.horiBearingY >> 6;
	outRect.w = face->glyph->metrics.width >> 6;
	outRect.h = face->glyph->metrics.height >> 6;
	xAdvance = (static_cast<int>(face->glyph->metrics.horiAdvance >> 6));
	// Next we need the spans for the outline.
	Spans outlineSpans;

	// Set up a stroker.
	FT_Stroker stroker;
	FT_Stroker_New(library, &stroker);
	FT_Stroker_Set(stroker,
			   (int)(outlineWidth * 64),
			   FT_STROKER_LINECAP_ROUND,
			   FT_STROKER_LINEJOIN_ROUND,
			   0);

	FT_Glyph glyph;
	if (FT_Get_Glyph(face->glyph, &glyph) != 0)
		return false;
	
	FT_Glyph_StrokeBorder(&glyph, stroker, 0, 1);
	// Again, this needs to be an outline to work.
	if (glyph->format == FT_GLYPH_FORMAT_OUTLINE)
	{
		// Render the outline spans to the span list
		FT_Outline *o =
		  &reinterpret_cast<FT_OutlineGlyph>(glyph)->outline;
		RenderSpans(library, o, &outlineSpans);
	}

	FT_BBox bbox;
	FT_Glyph_Get_CBox(glyph,FT_GLYPH_BBOX_GRIDFIT, &bbox);

	float bitmapWidth = (bbox.xMax - bbox.xMin)>>6;
    float bitmapHeight = (bbox.yMax - bbox.yMin)>>6;
 
	outRect.x = bbox.xMin >> 6;
	outRect.y = - (bbox.yMax >> 6);

	xAdvance += bitmapWidth - outRect.w;

    outRect.w =  bitmapWidth;
    outRect.h =  bitmapHeight;

	// Clean up afterwards.
	FT_Stroker_Done(stroker);
	FT_Done_Glyph(glyph);

	// Now we need to put it all together.
	if (spans.empty())
		return false;

	// Figure out what the bounding rect is for both the span lists.
	Rect rect(spans.front().x,
			  spans.front().y,
			  spans.front().x,
			  spans.front().y);
	for (Spans::iterator s = spans.begin();
		 s != spans.end(); ++s)
	{
		rect.Include(Vec2(s->x, s->y));
		rect.Include(Vec2(s->x + s->width - 1, s->y));
	}
	for (Spans::iterator s = outlineSpans.begin();
	 s != outlineSpans.end(); ++s)
	{
		rect.Include(Vec2(s->x, s->y));
		rect.Include(Vec2(s->x + s->width - 1, s->y));
	}

	// Get some metrics of our image.
	imgWidth = rect.Width();
	imgHeight = rect.Height();
	int	imgSize = imgWidth * imgHeight;

	// Allocate data for our image and clear it out to transparent.
	Pixel32 *pxl = new Pixel32[imgSize];
	memset(pxl, 0, sizeof(Pixel32) * imgSize);

	// Loop over the outline spans and just draw them into the
	// image.
	for (Spans::iterator s = outlineSpans.begin(); s != outlineSpans.end(); ++s)
	{
		for (int w = 0; w < s->width; ++w)
			pxl[(int)((imgHeight - 1 - (s->y - rect.ymin)) * imgWidth
			+ s->x - rect.xmin + w)] =
			Pixel32(outlineCol.r, outlineCol.g, outlineCol.b,
			s->coverage);
	}

	// Then loop over the regular glyph spans and blend them into
	// the image.
	for (Spans::iterator s = spans.begin(); s != spans.end(); ++s)
	{
		for (int w = 0; w < s->width; ++w)
		{
			Pixel32 &dst =
			  pxl[(int)((imgHeight - 1 - (s->y - rect.ymin)) * imgWidth
				  + s->x - rect.xmin + w)];
			Pixel32 src = Pixel32(fontCol.r, fontCol.g, fontCol.b,
								  s->coverage);
			dst.r = (int)(dst.r + ((src.r - dst.r) * src.a) / 255.0f);
			dst.g = (int)(dst.g + ((src.g - dst.g) * src.a) / 255.0f);
			dst.b = (int)(dst.b + ((src.b - dst.b) * src.a) / 255.0f);
			dst.a = MIN(255, dst.a + src.a);
		}
	}

	alpha_map = new char[imgWidth*imgHeight];
	RenderAlpha(pxl, imgWidth, imgHeight, alpha_map, color_top, color_bottom);
	delete pxl;

	
	return true;
}

FONT_OUTLINE_END